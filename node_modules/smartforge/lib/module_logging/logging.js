/*!
 * SmartForge - logging
 * Copyright(c) 2011 Gian Angelo Geminiani
 * MIT Licensed
 *
 * base on a work of Dylan Greene https://github.com/dylang
 * https://github.com/dylang/logging
 */

/**
 * Logging system with support for logging level ('error', 'warning', 'info', 'fine')
 */

/**
 * Module dependencies
 */
var utils = require('../utils.js')
    ,utilsFs = require('../utilsFs.js')
    ,style = require('./style.js')
    ;

// --------------------------------------------------------------------------------------------------------------
//                              initialization
// --------------------------------------------------------------------------------------------------------------

var clusterCPU = 'CLUSTER_WORKER' in process.env ? style(style.GREEN, process.env.CLUSTER_WORKER + '.') : '';

var TIMEZONE_OFFSET = (240 - (new Date).getTimezoneOffset()) * 60000;
TIMEZONE_OFFSET = TIMEZONE_OFFSET < stdTimezoneOffset() ? TIMEZONE_OFFSET + 3600000 : TIMEZONE_OFFSET;

var LEVELS = ['error', 'warning', 'info', 'fine'],
    LEVEL = 'info',
    USE_COLOR = true;

// --------------------------------------------------------------------------------------------------------------
//                              public
// --------------------------------------------------------------------------------------------------------------

function Logger(path) {
    var self = this;

    self._file = path ? utilsFs.pathBaseName(path).split('.')[0] : '';
    self._history = new Array();
    self._level = LEVEL;
    self._enablecolor = USE_COLOR;
}

Logger.prototype.log = function () {
    var file = this._file;
    record(this, utils.toArray(arguments), arguments.callee ? calledFrom(arguments.callee) : false, file);
};

Logger.prototype.array = function (array) {
    var file = this._file;
    record(this, array, arguments.callee ? calledFrom(arguments.callee) : false, file);
};

Logger.prototype.getHistory = function () {
    return this._history;
};

Logger.prototype.setLevel = function (level) {
    this._level = level;
};

Logger.prototype.enableColor = function (b) {
    this._enablecolor = b;
};

Logger.prototype.error = function () {
    var file = this._file,
        args = utils.toArray(arguments);
    args = utils.push(['error'], args);
    record(this, args, arguments.callee ? calledFrom(arguments.callee) : false, file);
};

Logger.prototype.warning = function () {
    var file = this._file,
        args = utils.toArray(arguments);
    args = utils.push(['warning'], args);
    record(this, args, arguments.callee ? calledFrom(arguments.callee) : false, file);
};

Logger.prototype.info = function () {
    var file = this._file,
        args = utils.toArray(arguments);
    args = utils.push(['info'], args);
    record(this, args, arguments.callee ? calledFrom(arguments.callee) : false, file);
};

Logger.prototype.fine = function () {
    var file = this._file,
        args = utils.toArray(arguments);
    args = utils.push(['fine'], args);
    record(this, args, arguments.callee ? calledFrom(arguments.callee) : false, file);
};

// --------------------------------------------------------------------------------------------------------------
//                              private
// --------------------------------------------------------------------------------------------------------------
function stdTimezoneOffset() {
    var fullYear = (new Date()).getFullYear();
    var jan = new Date(fullYear, 0, 1);
    var jul = new Date(fullYear, 6, 1);
    return Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset()) * 60000;
}

function writeLog(d) {

    var res = process.stdout.write(d + '\n');

    // this is the first time stdout got backed up
    if (!res && !process.stdout.pendingWrite) {
        process.stdout.pendingWrite = true;

        // magic sauce: keep node alive until stdout has flushed
        process.stdout.once('drain', function () {
            process.stdout.draining = false;
        });
    }
}

function format(self, message) {
    var enablecolor = self._enablecolor,
        result = message;
    switch (typeof message) {
        case 'string':
            result = enablecolor ? style(style.GREY, message) : message;
            break;
        case 'number':
            result = enablecolor ? style(style.YELLOW, message) : message;
            break;
        case 'function':
            result = enablecolor ? style(style.YELLOW_BOLD, message.toString()) : message.toString();
            break;
        default:
            message = utils.inspect(message, false, 6, enablecolor);
            if (message.length > 80) {
                message = ("\n" + message).split(/\n/).join("\n    ");
            }
            result = message;
            break;
    }
    return result;
}

function formatLevel(self, message) {
    var enablecolor = self._enablecolor,
        result = '[' + message.toUpperCase() + ']';
    if (message === 'error') {
        result = enablecolor ? style(style.RED_BOLD, result) : result;
    } else if (message === 'warning') {
        result = enablecolor ? style(style.MAGENTA_BOLD, result) : result;
    } else if (message === 'info') {
        result = enablecolor ? style(style.GREEN_BOLD, result) : result;
    } else if (message === 'fine') {
        result = enablecolor ? style(style.GREY_BOLD, result) : result;
    }
    return result;
}

function formatFunc(self, message) {
    var enablecolor = self._enablecolor,
        result = enablecolor ? style(style.GREEN, message) : message;

    return result;
}

function record(self, messages, func, file) {

    if (!messages) {
        return;
    }

    var date = new Date();
    date.setTime(date - TIMEZONE_OFFSET);
    var datetime = utils.formatDate(date);

    var output = [],
        count = 0,
        level;

    for (var i = 0; i < messages.length; i++) {

        var msg = messages[i];
        count++;
        if (count === 1) {
            var levelindex = LEVELS.indexOf(msg);
            if (levelindex > -1) {
                if (levelindex > LEVELS.indexOf(self._level)) {
                    // NO LOG
                    return;
                }
                output.push(formatLevel(self, msg));
                continue;
            }
        }
        output.push(format(self, msg));
    }

    writeLog(datetime + ' - '
        + (file || func ? '[' : '')
        + clusterCPU
        + (file ? formatFunc(self, file) : '')
        + (file && func ? '.' : '')
        + (func ? formatFunc(self, func) : '')
        + (file || func ? '] - ' : '')
        + output.join(' ').replace(/\n/g, '\n' + '            '));

    //-- add to history (max 100 items) --//
    if (self._history.length > 99) {
        self._history = [];
    } else {
        self._history.push({
            date:date,
            niceTime:datetime,
            file:file,
            func:func,
            messages:messages
        });
    }
}

function calledFrom(args, count) {
    return !args || count > 3
        ? false
        : (args.name && args.name != 'forEach' ? args.name : calledFrom(args.caller, count ? count + 1 : 1));
}

// --------------------------------------------------------------------------------------------------------------
//                              exports
// --------------------------------------------------------------------------------------------------------------

var __instance = new Logger(); // singleton instance

exports.Logger = module.exports.Logger = Logger;

exports.log = module.exports.log = function () {
    __instance.log.apply(__instance, arguments);
};
//-- set logging level (error, warning, info, fine) --//
exports.setLevel = module.exports.setLevel = function (level) {
    LEVEL = level;
    __instance.setLevel(level);
};
//-- enable or disable color usage in output --//
exports.enableColor = module.exports.enableColor = function (b) {
    USE_COLOR = b;
    __instance.enableColor(b);
};