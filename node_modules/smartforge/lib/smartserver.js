/*!
 * SmartForge - smartserver
 * SMARTSERVER: HTTP and SOCKET server.
 * This is main application controller.
 *
 * Copyright(c) 2011 Gian Angelo Geminiani
 * MIT Licensed
 */


/**
 * Module dependencies
 */
var utils = require('./utils.js')
    ,utilsFs = require('./utilsFs.js')
    ,application = require('./application')
    ,module_taskmanager = require('./module_taskmanager')
    ,module_socket = require('./module_socket')
    ,module_deploy = require('./module_deploy')
    // HTTP server
    ,http = require('http')
    // SOCKET server
    ,sockjs = require('sockjs')
    // MIDDLEWARE
    ,connect = require('connect')
    ;


// ---------------------------------------------------------------------------------------------------------------
//                              public
// ---------------------------------------------------------------------------------------------------------------

/**
 * Creates new instance of Application Server.
 * @param options {object}
 *      - debug {boolean}: (Optional) Default is False. If true are added some logs.
 *      - dirname {string}: set application root.
 *                          If omitted parent of __dirname become the root.
 *                          i.e. '/myapp' // htdocs= '/myapp/htdocs'
 *      - htdocs {string}: (Optional) Force HTDOCS into absolute path. Default is 'htdocs'
 *      - middleware {array}: (Optional) Array of middleware functions for Connect framework.
 *          Default is
 *          [connect.static(), connect.errorHandler()], or
 *          [connect.profiler, connect.logger(), connect.static(), connect.errorHandler()] if 'debug' option is true.
 */
function SmartServer(options) {
    var self = this;

    self.options = options || {};

    // constants
    self.EVENT_OPEN = 'open';
    self.EVENT_CLOSE = 'close';

    // path variables
    self.ROOT = options.dirname||utilsFs.pathResolve(__dirname, '..');
    self.PATH_WORKSPACE = options.workspace||utilsFs.pathResolve(self.ROOT, '_workspace');
    self.PATH_HTDOCS = options.htdocs;

    // status variables
    self._working = false;  // called open, but not still ready
    self._ready = false;    // ready! server has been initialized Async.

    //-- fields --//
    self._http = null;
    self._middleware = new Array();
    self.settings = null;
    self.taskmanager = null;
    self.socket = null;

    //-- logging --//
    self._logger = new application.getLogger(__filename);

    //-- initialize --//
    // _settings
    initSettings(self);
    // _taskmanager
    initTaskManager(self);
    // _socket
    initSocket(self);
}
// inherit EventEmitter
utils.inheritsEventEmitter(SmartServer);

SmartServer.prototype.toString = function () {
    return utils.format('SmartServer on Node {0}: ROOT="{1}" HTDOCS="{2}", TASKMANAGER=[{3}], SOCKET=[{4}], HTTP=[{5}]',
        process.version,
        this.ROOT, this.PATH_HTDOCS,
        this.taskmanager ? this.taskmanager.toString() : 'null',
        this.socket ? this.socket.toString() : 'null',
        this._http ? this._http.toString() : 'null'
    );
};

SmartServer.prototype.open = function (callback) {
    var self = this;

    open(self, callback);
};

SmartServer.prototype.close = function () {
    close(this);
};

SmartServer.prototype.isReady = function () {
    return this._ready;
};

SmartServer.prototype.addMiddleware = function (middlewareFunction) {
    if(this._middleware){
        this._middleware.push(middlewareFunction);
    }
};

// ---------------------------------------------------------------------------------------------------------------
//                              private
// ---------------------------------------------------------------------------------------------------------------

function open(self, callback) {
    if(!self._working){
        //-- load all middlewares --//
        loadMiddlewares(self);

        var httpsettings = self.settings&&self.settings.http;
        if(httpsettings){
            var http = openConnect(self), // creates HTTP connect object
                socket = self.socket;
            self._working = true;
            http.listen(httpsettings.port, httpsettings.domain, function listen() {
                self._logger.info('Server connected to: ',
                    {domain:httpsettings.domain , port:httpsettings.port});
                // default handler
                socket.installHandlers(http, {prefix:'[/]socket'});
                self._ready = true;
                if(utils.isFunction(callback)){
                    callback(self);
                }
            });
        }
    }
}

function openConnect(self){
    var middleware = self._middleware;
    self._http = connect.createServer.apply(self, middleware);
    return self._http;
}

function close(self) {
    if(self._working){
        self._working = false;
        self._ready = false;
        self._http.close();
        self._taskmanager.close();
    }
}

function initSettings(self){
    var settings = self.settings = new application.Settings({path:utilsFs.pathJoin(self.PATH_WORKSPACE, 'settings')});

    // HTDOCS
    if(null==self.PATH_HTDOCS){
        var settings_htdocs = settings.http?settings.http.htdocs:null;
        if(settings_htdocs){
            if(settings_htdocs.indexOf('.')===0){
                self.PATH_HTDOCS = utilsFs.pathResolve(self.ROOT, settings_htdocs);
            } else {
                self.PATH_HTDOCS = settings_htdocs;
            }
        } else {
            self.PATH_HTDOCS = utilsFs.pathJoin(self.ROOT, 'htdocs');
        }
    }

    // LOGGING
    if(settings.logging){
        var colors = settings.logging.colors||false,
            level = settings.logging.level||'info';
        application.setLogEnableColor(colors);
        application.setLogLevel(level);
        self._logger.enableColor(colors);
        self._logger.setLevel(level);
    }

    // DEPLOY
    if(settings.deploy && settings.deploy.resources){
        deploy(self, settings.deploy.resources);
    }
}

function initTaskManager(self){
    self.taskmanager = module_taskmanager.newInstance();
}

function initSocket(self){
    self.socket = module_socket.newInstance();
    self.socket.on('error', function onSocketError(err) {
        self._logger.log('Socket Error: ' + err);
    });
}


function deploy(self, resources){
    var deployer = new module_deploy.Deployer({
        root:self.ROOT,
        resources: resources,
        logger: self._logger
    });
    // log deploy info
    self._logger.info('BEGIN DEPLOY *');
    // start deploy
    deployer.deploy();
}

function loadMiddlewares(self){
    var options = self.options,
        debug = null!=options.debug?options.debug:false;

    if(debug){
        self._middleware.push(connect.profiler());
        self._middleware.push(connect.logger());
    }

    if(Array.isArray(options.middleware)){
        self._middleware.push.apply(self._middleware, options.middleware);
    }

    self._middleware.push(connect.errorHandler());
    self._middleware.push(connect.static(self.PATH_HTDOCS));
}

// ---------------------------------------------------------------------------------------------------------------
//                              exports
// ---------------------------------------------------------------------------------------------------------------

exports.SmartServer = SmartServer;
exports.newInstance = function (options) {
    return new SmartServer(options);
};


