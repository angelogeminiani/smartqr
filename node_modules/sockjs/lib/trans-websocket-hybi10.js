(function() {
  var WebHandshake8, WebSocket8Receiver, computeAcceptKey, transport, utils;
  var __hasProp = Object.prototype.hasOwnProperty, __extends = function(child, parent) {
    for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor;
    child.__super__ = parent.prototype;
    return child;
  }, __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
  utils = require('./utils');
  transport = require('./transport');
  computeAcceptKey = function(key) {
    var data;
    data = key.match(/\S+/)[0] + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';
    return utils.sha1_base64(data);
  };
  WebHandshake8 = (function() {
    function WebHandshake8(server, req, connection, head, origin, location) {
      var blob, key_accept;
      this.server = server;
      this.req = req;
      this.connection = connection;
      key_accept = computeAcceptKey(this.req.headers['sec-websocket-key']);
      blob = ['HTTP/1.1 101 Switching Protocols', 'Upgrade: WebSocket', 'Connection: Upgrade', 'Sec-WebSocket-Accept: ' + key_accept];
      if (this.req.headers['sec-websocket-protocol']) {
        blob.push('Sec-WebSocket-Protocol: ' + this.req.headers['sec-websocket-protocol'].split(',')[0]);
      }
      try {
        this.connection.write(blob.concat('', '').join('\r\n'), 'utf8');
        this.connection.setTimeout(0);
        this.connection.setNoDelay(true);
        this.connection.setEncoding('binary');
      } catch (e) {
        try {
          this.connection.end();
        } catch (x) {

        }
        return;
      }
      transport.registerNoSession(this.req, this.server, new WebSocket8Receiver(this.connection));
    }
    return WebHandshake8;
  })();
  WebSocket8Receiver = (function() {
    __extends(WebSocket8Receiver, transport.ConnectionReceiver);
    WebSocket8Receiver.prototype.protocol = "websocket";
    function WebSocket8Receiver() {
      this.recv_buffer = new Buffer(0);
      WebSocket8Receiver.__super__.constructor.apply(this, arguments);
    }
    WebSocket8Receiver.prototype.setUp = function() {
      this.data_cb = __bind(function(data) {
        return this.didMessage(data);
      }, this);
      this.connection.addListener('data', this.data_cb);
      return WebSocket8Receiver.__super__.setUp.apply(this, arguments);
    };
    WebSocket8Receiver.prototype.tearDown = function() {
      this.connection.removeListener('data', this.data_cb);
      this.data_cb = void 0;
      return WebSocket8Receiver.__super__.tearDown.apply(this, arguments);
    };
    WebSocket8Receiver.prototype.didMessage = function(bin_data) {
      var buf, i, key, l, length, masking, message, opcode, payload, payload_str, reason, status;
      if (bin_data) {
        this.recv_buffer = utils.buffer_concat(this.recv_buffer, new Buffer(bin_data, 'binary'));
      }
      buf = this.recv_buffer;
      if (buf.length < 2) {
        return;
      }
      if ((buf[0] & 128) !== 128) {
        console.error('fin flag not set');
        this.didClose(1002, "Fin flag not set");
        return;
      }
      opcode = buf[0] & 0xF;
      if (opcode !== 1 && opcode !== 8) {
        console.error('not a text nor close frame', buf[0] & 0xF);
        this.didClose(1002, "not a text nor close frame");
        return;
      }
      if (opcode === 8 && !((buf[1] & 0x7F) < 126)) {
        console.error('wrong length for close frame');
        this.didClose(1002, 'wrong length for close frame');
        return;
      }
      masking = !(!(buf[1] & 128));
      if ((buf[1] & 0x7F) < 126) {
        length = buf[1] & 0x7F;
        l = 2;
      } else if ((buf[1] & 0x7F) === 126) {
        if (buf.length < 4) {
          return;
        }
        length = (buf[2] << 8) | (buf[3] << 0);
        l = 4;
      } else if ((buf[1] & 0x7F) === 127) {
        if (buf.length < 10) {
          return;
        }
        length = (buf[2] << 56) | (buf[3] << 48) | (buf[4] << 40) | (buf[5] << 32) | (buf[6] << 24) | (buf[7] << 16) | (buf[8] << 8) | (buf[9] << 0);
        l = 10;
      }
      if (masking) {
        if (buf.length < l + 4) {
          return;
        }
        key = new Buffer(4);
        key[0] = buf[l + 0];
        key[1] = buf[l + 1];
        key[2] = buf[l + 2];
        key[3] = buf[l + 3];
        l += 4;
      }
      if (buf.length < l + length) {
        return;
      }
      payload = buf.slice(l, l + length);
      if (masking) {
        for (i = 0; 0 <= length ? i < length : i > length; 0 <= length ? i++ : i--) {
          payload[i] = payload[i] ^ key[i % 4];
        }
      }
      this.recv_buffer = buf.slice(l + length);
      if (opcode === 1) {
        payload_str = payload.toString('utf-8');
        if (this.session && payload_str.length > 0) {
          try {
            message = JSON.parse(payload_str);
          } catch (e) {
            return this.didClose(1002, 'Broken framing.');
          }
          this.session.didMessage(message);
        }
        if (this.recv_buffer) {
          return this.didMessage();
        }
      } else if (opcode === 8) {
        if (payload.length >= 2) {
          status = (payload[0] << 8) | (payload[1] << 0);
        } else {
          status = 1002;
        }
        if (payload.length > 2) {
          reason = payload.slice(2).toString('utf-8');
        } else {
          reason = "Connection closed by user";
        }
        this.didClose(status, reason);
      }
    };
    WebSocket8Receiver.prototype.doSendFrame = function(payload) {
      var a, i, key, l, pl, pl2, _ref;
      payload = new Buffer(payload, 'utf-8');
      pl = payload.length;
      a = new Buffer(pl + 14);
      a[0] = 128 + 1;
      a[1] = 128;
      l = 2;
      if (pl < 126) {
        a[1] |= pl;
      } else if (pl < 65536) {
        a[1] |= 126;
        a[l + 0] = (pl >> 8) & 0xff;
        a[l + 1] = (pl >> 0) & 0xff;
        l += 2;
      } else {
        pl2 = pl;
        a[1] |= 127;
        for (i = 7, _ref = -1; 7 <= _ref ? i < _ref : i > _ref; 7 <= _ref ? i++ : i--) {
          a[l + i] = pl2 & 0xff;
          pl2 = pl2 >> 8;
        }
        l += 8;
      }
      key = new Buffer(4);
      a[l + 0] = key[0] = Math.floor(Math.random() * 256);
      a[l + 1] = key[1] = Math.floor(Math.random() * 256);
      a[l + 2] = key[2] = Math.floor(Math.random() * 256);
      a[l + 3] = key[3] = Math.floor(Math.random() * 256);
      l += 4;
      for (i = 0; 0 <= pl ? i < pl : i > pl; 0 <= pl ? i++ : i--) {
        a[l + i] = payload[i] ^ key[i % 4];
      }
      l += pl;
      return WebSocket8Receiver.__super__.doSendFrame.call(this, a.slice(0, l), 'binary');
    };
    return WebSocket8Receiver;
  })();
  exports.WebHandshake8 = WebHandshake8;
}).call(this);
