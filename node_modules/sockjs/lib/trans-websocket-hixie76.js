(function() {
  var WebHandshakeHixie76, WebSocketReceiver, crypto, transport, utils, validateCrypto;
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; }, __hasProp = Object.prototype.hasOwnProperty, __extends = function(child, parent) {
    for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor;
    child.__super__ = parent.prototype;
    return child;
  };
  crypto = require('crypto');
  utils = require('./utils');
  transport = require('./transport');
  validateCrypto = function(req_headers, nonce) {
    var k, k1, k2, md5, n, s, spaces, _i, _len, _ref;
    k1 = req_headers['sec-websocket-key1'];
    k2 = req_headers['sec-websocket-key2'];
    if (!k1 || !k2) {
      return false;
    }
    md5 = crypto.createHash('md5');
    _ref = [k1, k2];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      k = _ref[_i];
      n = parseInt(k.replace(/[^\d]/g, ''));
      spaces = k.replace(/[^ ]/g, '').length;
      if (spaces === 0 || n % spaces !== 0) {
        return false;
      }
      n /= spaces;
      s = String.fromCharCode(n >> 24 & 0xFF, n >> 16 & 0xFF, n >> 8 & 0xFF, n & 0xFF);
      md5.update(s);
    }
    md5.update(nonce.toString('binary'));
    return md5.digest('binary');
  };
  WebHandshakeHixie76 = (function() {
    function WebHandshakeHixie76(server, req, connection, head, origin, location) {
      var blob, prefix, wsp;
      this.server = server;
      this.req = req;
      this.connection = connection;
      this.sec = 'sec-websocket-key1' in this.req.headers;
      wsp = this.sec && ('sec-websocket-protocol' in this.req.headers);
      prefix = this.sec ? 'Sec-' : '';
      blob = ['HTTP/1.1 101 WebSocket Protocol Handshake', 'Upgrade: WebSocket', 'Connection: Upgrade', prefix + 'WebSocket-Origin: ' + origin, prefix + 'WebSocket-Location: ' + location];
      if (wsp) {
        blob.push('Sec-WebSocket-Protocol: ' + this.req.headers['sec-websocket-protocol'].split(',')[0]);
      }
      this._setup();
      try {
        this.connection.write(blob.concat('', '').join('\r\n'), 'utf8');
        this.connection.setTimeout(0);
        this.connection.setNoDelay(true);
        this.connection.setEncoding('binary');
      } catch (e) {
        this.didClose();
        return;
      }
      this.buffer = new Buffer(0);
      this.didMessage(head);
      return;
    }
    WebHandshakeHixie76.prototype._setup = function() {
      this.close_cb = __bind(function() {
        return this.didClose();
      }, this);
      this.connection.addListener('end', this.close_cb);
      this.data_cb = __bind(function(data) {
        return this.didMessage(data);
      }, this);
      return this.connection.addListener('data', this.data_cb);
    };
    WebHandshakeHixie76.prototype._cleanup = function() {
      this.connection.removeListener('end', this.close_cb);
      this.connection.removeListener('data', this.data_cb);
      return this.close_cb = this.data_cb = void 0;
    };
    WebHandshakeHixie76.prototype.didClose = function() {
      if (this.connection) {
        this._cleanup();
        try {
          this.connection.end();
        } catch (x) {

        }
        return this.connection = void 0;
      }
    };
    WebHandshakeHixie76.prototype.didMessage = function(bin_data) {
      this.buffer = utils.buffer_concat(this.buffer, new Buffer(bin_data, 'binary'));
      if (this.sec === false || this.buffer.length >= 8) {
        return this.gotEnough();
      }
    };
    WebHandshakeHixie76.prototype.gotEnough = function() {
      var nonce, reply;
      this._cleanup();
      if (this.sec) {
        nonce = this.buffer.slice(0, 8);
        this.buffer = this.buffer.slice(8);
        reply = validateCrypto(this.req.headers, nonce);
        if (reply === false) {
          this.didClose();
          return false;
        }
        try {
          this.connection.write(reply, 'binary');
        } catch (x) {
          this.didClose();
          return false;
        }
      }
      return transport.registerNoSession(this.req, this.server, new WebSocketReceiver(this.connection));
    };
    return WebHandshakeHixie76;
  })();
  WebSocketReceiver = (function() {
    __extends(WebSocketReceiver, transport.ConnectionReceiver);
    WebSocketReceiver.prototype.protocol = "websocket";
    function WebSocketReceiver() {
      this.recv_buffer = new Buffer(0);
      WebSocketReceiver.__super__.constructor.apply(this, arguments);
    }
    WebSocketReceiver.prototype.setUp = function() {
      this.data_cb = __bind(function(data) {
        return this.didMessage(data);
      }, this);
      this.connection.addListener('data', this.data_cb);
      return WebSocketReceiver.__super__.setUp.apply(this, arguments);
    };
    WebSocketReceiver.prototype.tearDown = function() {
      this.connection.removeListener('data', this.data_cb);
      this.data_cb = void 0;
      return WebSocketReceiver.__super__.tearDown.apply(this, arguments);
    };
    WebSocketReceiver.prototype.didMessage = function(bin_data) {
      var buf, i, message, payload, _ref;
      if (bin_data) {
        this.recv_buffer = utils.buffer_concat(this.recv_buffer, new Buffer(bin_data, 'binary'));
      }
      buf = this.recv_buffer;
      if (buf.length === 0) {
        return;
      }
      if (buf[0] === 0x00) {
        for (i = 1, _ref = buf.length; 1 <= _ref ? i < _ref : i > _ref; 1 <= _ref ? i++ : i--) {
          if (buf[i] === 0xff) {
            payload = buf.slice(1, i).toString('utf8');
            this.recv_buffer = buf.slice(i + 1);
            if (this.session && payload.length > 0) {
              try {
                message = JSON.parse(payload);
              } catch (x) {
                return this.didClose(1002, 'Broken framing.');
              }
              this.session.didMessage(message);
            }
            return this.didMessage();
          }
        }
        return;
      } else if (buf[0] === 0xff && buf[1] === 0x00) {
        this.didClose(1001, "Socket closed by the client");
      } else {
        this.didClose(1002, "Broken framing");
      }
    };
    WebSocketReceiver.prototype.doSendFrame = function(payload) {
      var a, l;
      a = new Buffer((payload.length + 2) * 6);
      l = 0;
      l += a.write('\u0000', l, 'binary');
      l += a.write('' + payload, l, 'utf-8');
      l += a.write('\uffff', l, 'binary');
      return WebSocketReceiver.__super__.doSendFrame.call(this, a.slice(0, l), 'binary');
    };
    return WebSocketReceiver;
  })();
  exports.WebHandshakeHixie76 = WebHandshakeHixie76;
}).call(this);
